/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b9538de0-776f-4412-8587-f2be02397402

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formal verification of the Weyl Orbit Unification for the Canonical Six P-vectors in E₈.
Includes definitions of the 8D vector space, roots, and Weyl reflections.
Proves that the five distinct images of the P-vectors have squared norm 2,
identifies an antipodal pair connected by a simple reflection,
and verifies that all vectors reduce to the same dominant weight λ under the given Weyl group elements.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def CD : Nat → Type
  | 0 => ℚ
  | n + 1 => CD n × CD n

instance instInhabitedCD (n : Nat) : Inhabited (CD n) :=
  match n with
  | 0 => inferInstanceAs (Inhabited ℚ)
  | n + 1 => @instInhabitedProd (CD n) (CD n) (instInhabitedCD n) (instInhabitedCD n)

instance instZeroCD (n : Nat) : Zero (CD n) :=
  match n with
  | 0 => inferInstanceAs (Zero ℚ)
  | n + 1 => @Prod.instZero (CD n) (CD n) (instZeroCD n) (instZeroCD n)

instance instOneCD (n : Nat) : One (CD n) :=
  match n with
  | 0 => inferInstanceAs (One ℚ)
  | n + 1 => @Prod.instOne (CD n) (CD n) (instOneCD n) (instOneCD n)

instance instAddCD (n : Nat) : Add (CD n) :=
  match n with
  | 0 => inferInstanceAs (Add ℚ)
  | n + 1 =>
    let _ : Add (CD n) := instAddCD n
    ⟨fun a b => (a.1 + b.1, a.2 + b.2)⟩

instance instNegCD (n : Nat) : Neg (CD n) :=
  match n with
  | 0 => inferInstanceAs (Neg ℚ)
  | n + 1 =>
    let _ : Neg (CD n) := instNegCD n
    ⟨fun a => (-a.1, -a.2)⟩

instance instSubCD (n : Nat) : Sub (CD n) :=
  match n with
  | 0 => inferInstanceAs (Sub ℚ)
  | n + 1 =>
    let _ : Sub (CD n) := instSubCD n
    ⟨fun a b => (a.1 - b.1, a.2 - b.2)⟩

instance instStarCD (n : Nat) : Star (CD n) :=
  match n with
  | 0 => inferInstanceAs (Star ℚ)
  | n + 1 =>
    let _ : Star (CD n) := instStarCD n
    let _ : Neg (CD n) := instNegCD n
    ⟨fun a => (star a.1, -a.2)⟩

instance instMulCD (n : Nat) : Mul (CD n) :=
  match n with
  | 0 => inferInstanceAs (Mul ℚ)
  | n + 1 =>
    let _ : Mul (CD n) := instMulCD n
    let _ : Add (CD n) := instAddCD n
    let _ : Sub (CD n) := instSubCD n
    let _ : Star (CD n) := instStarCD n
    ⟨fun a b => (a.1 * b.1 - star b.2 * a.2, b.2 * a.1 + a.2 * star b.1)⟩

instance instAddCommGroupCD (n : Nat) : AddCommGroup (CD n) :=
  match n with
  | 0 => inferInstanceAs (AddCommGroup ℚ)
  | n + 1 =>
    let _ : AddCommGroup (CD n) := instAddCommGroupCD n
    @Prod.instAddCommGroup (CD n) (CD n) (instAddCommGroupCD n) (instAddCommGroupCD n)

def basis (n : Nat) (k : Nat) : CD n :=
  match n with
  | 0 => if k == 0 then 1 else 0
  | n + 1 =>
    if k < 2^n then (basis n k, 0)
    else (0, basis n (k - 2^n))

abbrev e (n : Nat) (k : Nat) : CD n := basis n k

def P1 (n : Nat) : CD n := e n 1 + e n 14
def Q1 (n : Nat) : CD n := e n 3 + e n 12
def P2 (n : Nat) : CD n := e n 3 + e n 12
def Q2 (n : Nat) : CD n := e n 5 + e n 10
def P3 (n : Nat) : CD n := e n 4 + e n 11
def Q3 (n : Nat) : CD n := e n 6 + e n 9
def P4 (n : Nat) : CD n := e n 1 - e n 14
def Q4 (n : Nat) : CD n := e n 3 - e n 12
def P5 (n : Nat) : CD n := e n 1 - e n 14
def Q5 (n : Nat) : CD n := e n 5 + e n 10
def P6 (n : Nat) : CD n := e n 2 - e n 13
def Q6 (n : Nat) : CD n := e n 6 + e n 9

def bracket {α : Type} [Mul α] [Sub α] (a b : α) : α := a * b - b * a

def IsBilateralZeroDivisor {α : Type} [Mul α] [Zero α] (a b : α) : Prop :=
  a * b = 0 ∧ b * a = 0

/-
Define V8, dot product, norm squared, the five P-vectors, the eight simple roots, and the target weight lambda.
-/
abbrev V8 := Fin 8 → ℚ

def mkV8 (x0 x1 x2 x3 x4 x5 x6 x7 : ℚ) : V8 :=
  ![x0, x1, x2, x3, x4, x5, x6, x7]

def dot (u v : V8) : ℚ :=
  u 0 * v 0 + u 1 * v 1 + u 2 * v 2 + u 3 * v 3 +
  u 4 * v 4 + u 5 * v 5 + u 6 * v 6 + u 7 * v 7

def norm_sq (v : V8) : ℚ := dot v v

def v1 : V8 := mkV8 0 1 0 0 0 0 (-1) 0
def v2 : V8 := mkV8 0 0 0 1 (-1) 0 0 0
def v3 : V8 := mkV8 0 0 0 (-1) 1 0 0 0
def v4 : V8 := mkV8 0 1 0 0 0 0 1 0
def v5 : V8 := mkV8 0 0 1 0 0 1 0 0

def α1 : V8 := mkV8 1 (-1) 0 0 0 0 0 0
def α2 : V8 := mkV8 0 1 (-1) 0 0 0 0 0
def α3 : V8 := mkV8 0 0 1 (-1) 0 0 0 0
def α4 : V8 := mkV8 0 0 0 1 (-1) 0 0 0
def α5 : V8 := mkV8 0 0 0 0 1 (-1) 0 0
def α6 : V8 := mkV8 0 0 0 0 0 1 1 0
def α7 : V8 := mkV8 (-1/2) (-1/2) (-1/2) (-1/2) (-1/2) (-1/2) (-1/2) (-1/2)
def α8 : V8 := mkV8 0 0 0 0 0 1 (-1) 0

def target_lambda : V8 := mkV8 1 0 0 0 0 0 0 (-1)

/-
Define the Weyl reflection s, a helper to get roots by index, and a function to apply a sequence of reflections.
-/
def s (α v : V8) : V8 := fun i => v i - (2 * dot v α / dot α α) * α i

def get_root (k : Nat) : V8 :=
  match k with
  | 1 => α1
  | 2 => α2
  | 3 => α3
  | 4 => α4
  | 5 => α5
  | 6 => α6
  | 7 => α7
  | 8 => α8
  | _ => mkV8 0 0 0 0 0 0 0 0

def apply_reflection_sequence (v : V8) (seq : List Nat) : V8 :=
  seq.foldl (fun acc k => s (get_root k) acc) v

/-
Theorem 1a (E₈ shell): All five vectors have squared norm 2.
-/
theorem Theorem_1a : norm_sq v1 = 2 ∧ norm_sq v2 = 2 ∧ norm_sq v3 = 2 ∧ norm_sq v4 = 2 ∧ norm_sq v5 = 2 := by
  native_decide +revert

/-
Theorem 1b (Antipodal pair): v2 + v3 = 0, and the single simple reflection s_α4 maps v2 to v3.
-/
theorem Theorem_1b : v2 + v3 = 0 ∧ s α4 v2 = v3 := by
  native_decide +revert

/-
Theorem 1c (Single Weyl orbit): All five vectors reduce to the dominant weight λ under the greedy Weyl reduction algorithm using the provided reduction sequences.
-/
def seq1 : List Nat := [1,6,5,4,3,2,7,6,5,4,3,8,5,4,6,5,7,6,8,5,4,3,2,1]
def seq2 : List Nat := [3,2,1,5,6,7,8,5,4,3,2,6,5,4,3,8,5,4,6,5,7,6,8,5,4,3,2,1]
def seq3 : List Nat := [4,3,2,1,5,6,7,8,5,4,3,2,6,5,4,3,8,5,4,6,5,7,6,8,5,4,3,2,1]
def seq4 : List Nat := [1,7,8,5,4,3,2,6,5,4,3,8,5,4,6,5,7,6,8,5,4,3,2,1]
def seq5 : List Nat := [2,1,5,4,3,2,7,6,5,4,3,8,5,4,6,5,7,6,8,5,4,3,2,1]

theorem Theorem_1c :
  apply_reflection_sequence v1 seq1 = target_lambda ∧
  apply_reflection_sequence v2 seq2 = target_lambda ∧
  apply_reflection_sequence v3 seq3 = target_lambda ∧
  apply_reflection_sequence v4 seq4 = target_lambda ∧
  apply_reflection_sequence v5 seq5 = target_lambda := by
    decide +kernel