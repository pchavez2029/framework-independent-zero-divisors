/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2bfe90a4-c7c3-4467-85d8-ab1bcac6b6e3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: af901513-bb0e-4c6a-a336-91c5477e5f3a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formal verification of the Canonical Six bilateral zero divisor patterns in the Cayley-Dickson algebras CD4 (sedenions), CD5 (pathions), and CD6 (chingons).
We define the Cayley-Dickson construction over ℚ recursively.
We define the six specific patterns of elements (P_i, Q_i).
We prove that for each pattern i ∈ {1..6} and dimension n ∈ {4, 5, 6}, (P_i, Q_i) is a bilateral zero divisor pair (P_i * Q_i = 0 and Q_i * P_i = 0).
We also prove that the commutator [P_i, Q_i] vanishes for all these cases, as a consequence of the bilateral zero divisor property.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Star

#check (inferInstance : Star ℚ)

/-
Definition of the Cayley-Dickson algebra type family CD. CD 0 is the rationals, and CD (n+1) is the product of CD n with itself.
-/
def CD : Nat → Type
  | 0 => ℚ
  | n + 1 => CD n × CD n

/-
Inhabited instance for CD n.
-/
instance instInhabitedCD (n : Nat) : Inhabited (CD n) :=
  match n with
  | 0 => inferInstanceAs (Inhabited ℚ)
  | n + 1 => @instInhabitedProd (CD n) (CD n) (instInhabitedCD n) (instInhabitedCD n)

/-
Zero instance for CD n.
-/
instance instZeroCD (n : Nat) : Zero (CD n) :=
  match n with
  | 0 => inferInstanceAs (Zero ℚ)
  | n + 1 => @Prod.instZero (CD n) (CD n) (instZeroCD n) (instZeroCD n)

/-
One instance for CD n.
-/
instance instOneCD (n : Nat) : One (CD n) :=
  match n with
  | 0 => inferInstanceAs (One ℚ)
  | n + 1 => @Prod.instOne (CD n) (CD n) (instOneCD n) (instOneCD n)

/-
Add instance for CD n.
-/
instance instAddCD (n : Nat) : Add (CD n) :=
  match n with
  | 0 => inferInstanceAs (Add ℚ)
  | n + 1 =>
    let _ : Add (CD n) := instAddCD n
    ⟨fun a b => (a.1 + b.1, a.2 + b.2)⟩

/-
Neg instance for CD n.
-/
instance instNegCD (n : Nat) : Neg (CD n) :=
  match n with
  | 0 => inferInstanceAs (Neg ℚ)
  | n + 1 =>
    let _ : Neg (CD n) := instNegCD n
    ⟨fun a => (-a.1, -a.2)⟩

/-
Sub instance for CD n.
-/
instance instSubCD (n : Nat) : Sub (CD n) :=
  match n with
  | 0 => inferInstanceAs (Sub ℚ)
  | n + 1 =>
    let _ : Sub (CD n) := instSubCD n
    ⟨fun a b => (a.1 - b.1, a.2 - b.2)⟩

/-
Star instance for CD n.
-/
instance instStarCD (n : Nat) : Star (CD n) :=
  match n with
  | 0 => inferInstanceAs (Star ℚ)
  | n + 1 =>
    let _ : Star (CD n) := instStarCD n
    let _ : Neg (CD n) := instNegCD n
    ⟨fun a => (star a.1, -a.2)⟩

/-
Mul instance for CD n using the Cayley-Dickson construction: (a, b)(c, d) = (ac - d*b, da + bc*). Note that the order of multiplication matters due to non-commutativity. The formula is standard: (a,b)(c,d) = (ac - d^*b, da + bc^*). Wait, let me double check the formula.
Standard Cayley-Dickson: (a,b)(c,d) = (ac - d^*b, da + bc^*).
Let's check the user's text: "(a, b)(c, d) = (ac − d*b, da + bc*)".
My code: `(a.1 * b.1 - star b.2 * a.2, b.2 * a.1 + a.2 * star b.1)`.
a=(a.1, a.2), b=(b.1, b.2).
So a.1=a, a.2=b, b.1=c, b.2=d.
Formula: (ac - d*b, da + bc*).
My code:
First component: a.1 * b.1 - star b.2 * a.2  => ac - d*b. Correct.
Second component: b.2 * a.1 + a.2 * star b.1 => da + bc*. Correct.
Wait, is it `da + bc*` or `cb + da*`?
User text says: `(ac − d*b, da + bc*)`.
Mathlib or standard sources usually say: `(a,b)(c,d) = (ac - d^*b, da + bc^*)` or similar.
I will stick to the user's formula: `(ac − d*b, da + bc*)`.
So `(a.1 * b.1 - star b.2 * a.2, b.2 * a.1 + a.2 * star b.1)`.
Wait, `d*b` means `(star d) * b`.
My code: `star b.2 * a.2`. `b.2` is `d`, `a.2` is `b`. So `d*b`. Correct.
`da` means `d * a`.
My code: `b.2 * a.1`. `b.2` is `d`, `a.1` is `a`. So `da`. Correct.
`bc*` means `b * (star c)`.
My code: `a.2 * star b.1`. `a.2` is `b`, `b.1` is `c`. So `bc*`. Correct.
-/
instance instMulCD (n : Nat) : Mul (CD n) :=
  match n with
  | 0 => inferInstanceAs (Mul ℚ)
  | n + 1 =>
    let _ : Mul (CD n) := instMulCD n
    let _ : Add (CD n) := instAddCD n
    let _ : Sub (CD n) := instSubCD n
    let _ : Star (CD n) := instStarCD n
    ⟨fun a b => (a.1 * b.1 - star b.2 * a.2, b.2 * a.1 + a.2 * star b.1)⟩

/-
Definition of the basis element e_k in CD n.
For n=0, e_0 = 1, others 0.
For n+1, e_k = (e_k, 0) if k < 2^n, and (0, e_{k-2^n}) if k >= 2^n.
-/
def basis (n : Nat) (k : Nat) : CD n :=
  match n with
  | 0 => if k == 0 then 1 else 0
  | n + 1 =>
    if k < 2^n then
      (basis n k, 0)
    else
      (0, basis n (k - 2^n))

/-
Abbreviation e for basis to match user notation.
-/
abbrev e (n : Nat) (k : Nat) : CD n := basis n k

/-
Definitions of the six pairs of elements (P_i, Q_i) for the Canonical Six patterns, parameterized by the dimension index n.
Pattern 1: P1 = e₁ + e₁₄, Q1 = e₃ + e₁₂
Pattern 2: P2 = e₃ + e₁₂, Q2 = e₅ + e₁₀
Pattern 3: P3 = e₄ + e₁₁, Q3 = e₆ + e₉
Pattern 4: P4 = e₁ - e₁₄, Q4 = e₃ - e₁₂
Pattern 5: P5 = e₁ - e₁₄, Q5 = e₅ + e₁₀
Pattern 6: P6 = e₂ - e₁₃, Q6 = e₆ + e₉
-/
def P1 (n : Nat) : CD n := e n 1 + e n 14
def Q1 (n : Nat) : CD n := e n 3 + e n 12

def P2 (n : Nat) : CD n := e n 3 + e n 12
def Q2 (n : Nat) : CD n := e n 5 + e n 10

def P3 (n : Nat) : CD n := e n 4 + e n 11
def Q3 (n : Nat) : CD n := e n 6 + e n 9

def P4 (n : Nat) : CD n := e n 1 - e n 14
def Q4 (n : Nat) : CD n := e n 3 - e n 12

def P5 (n : Nat) : CD n := e n 1 - e n 14
def Q5 (n : Nat) : CD n := e n 5 + e n 10

def P6 (n : Nat) : CD n := e n 2 - e n 13
def Q6 (n : Nat) : CD n := e n 6 + e n 9

/-
Definition of the commutator [a, b] = ab - ba.
-/
def bracket {α : Type} [Mul α] [Sub α] (a b : α) : α := a * b - b * a

/-
Definition of the bilateral zero divisor property: ab = 0 and ba = 0.
-/
def IsBilateralZeroDivisor {α : Type} [Mul α] [Zero α] (a b : α) : Prop :=
  a * b = 0 ∧ b * a = 0

/-
Pattern 1 is a bilateral zero divisor in CD4 (16D sedenions).
(e₁ + e₁₄) × (e₃ + e₁₂) = 0 and (e₃ + e₁₂) × (e₁ + e₁₄) = 0.
-/
theorem Pattern1_CD4 : IsBilateralZeroDivisor (P1 4) (Q1 4) := by
  constructor <;> norm_cast

/-
Pattern 2 is a bilateral zero divisor in CD4.
(e₃ + e₁₂) × (e₅ + e₁₀) = 0 and (e₅ + e₁₀) × (e₃ + e₁₂) = 0.
-/
theorem Pattern2_CD4 : IsBilateralZeroDivisor (P2 4) (Q2 4) := by
  unfold IsBilateralZeroDivisor P2 Q2 e basis
  -- The computation is heavy, so we use native_decide or decide if possible, but since we are using Rat, we might need to just let the kernel reduce it.
  -- However, `rfl` might be too slow if not careful.
  -- Let's try `native_decide` if we can derive DecidableEq, or just `rfl`.
  -- Since `CD n` is just nested pairs of Rationals, equality is decidable.
  -- But `native_decide` requires `Decidable` instance for the proposition.
  -- Equality on `CD n` is decidable.
  constructor <;> norm_cast

/-
Pattern 3 is a bilateral zero divisor in CD4.
(e₄ + e₁₁) × (e₆ + e₉) = 0 and (e₆ + e₉) × (e₄ + e₁₁) = 0.
-/
theorem Pattern3_CD4 : IsBilateralZeroDivisor (P3 4) (Q3 4) := by
  constructor <;> norm_cast

/-
Pattern 4 is a bilateral zero divisor in CD4.
(e₁ - e₁₄) × (e₃ - e₁₂) = 0 and (e₃ - e₁₂) × (e₁ - e₁₄) = 0.
-/
theorem Pattern4_CD4 : IsBilateralZeroDivisor (P4 4) (Q4 4) := by
  constructor <;> norm_cast

/-
Pattern 5 is a bilateral zero divisor in CD4.
(e₁ - e₁₄) × (e₅ + e₁₀) = 0 and (e₅ + e₁₀) × (e₁ - e₁₄) = 0.
-/
theorem Pattern5_CD4 : IsBilateralZeroDivisor (P5 4) (Q5 4) := by
  constructor <;> norm_cast

/-
Pattern 6 is a bilateral zero divisor in CD4.
(e₂ - e₁₃) × (e₆ + e₉) = 0 and (e₆ + e₉) × (e₂ - e₁₃) = 0.
-/
theorem Pattern6_CD4 : IsBilateralZeroDivisor (P6 4) (Q6 4) := by
  constructor <;> norm_cast

/-
Instance of AddCommGroup for CD n. This provides all the necessary additive properties like 0 - 0 = 0.
-/
instance instAddCommGroupCD (n : Nat) : AddCommGroup (CD n) :=
  match n with
  | 0 => inferInstanceAs (AddCommGroup ℚ)
  | n + 1 =>
    let _ : AddCommGroup (CD n) := instAddCommGroupCD n
    @Prod.instAddCommGroup (CD n) (CD n) (instAddCommGroupCD n) (instAddCommGroupCD n)

/-
Lemma: Bilateral zero divisors have vanishing commutators.
If ab = 0 and ba = 0, then [a, b] = ab - ba = 0 - 0 = 0.
-/
lemma bracket_eq_zero_of_bilateral_zero_divisor {α : Type} [Mul α] [AddCommGroup α] (a b : α) (h : IsBilateralZeroDivisor a b) : bracket a b = 0 := by
  unfold bracket IsBilateralZeroDivisor at *
  rw [h.1, h.2, sub_zero]

/-
Pattern 1 is a bilateral zero divisor in CD5 (32D pathions).
(e₁ + e₁₄) × (e₃ + e₁₂) = 0 and (e₃ + e₁₂) × (e₁ + e₁₄) = 0.
-/
theorem Pattern1_CD5 : IsBilateralZeroDivisor (P1 5) (Q1 5) := by
  constructor <;> norm_cast

/-
Pattern 2 is a bilateral zero divisor in CD5.
(e₃ + e₁₂) × (e₅ + e₁₀) = 0 and (e₅ + e₁₀) × (e₃ + e₁₂) = 0.
-/
theorem Pattern2_CD5 : IsBilateralZeroDivisor (P2 5) (Q2 5) := by
  constructor <;> norm_cast

/-
Pattern 3 is a bilateral zero divisor in CD5.
(e₄ + e₁₁) × (e₆ + e₉) = 0 and (e₆ + e₉) × (e₄ + e₁₁) = 0.
-/
theorem Pattern3_CD5 : IsBilateralZeroDivisor (P3 5) (Q3 5) := by
  constructor <;> norm_cast

/-
Pattern 4 is a bilateral zero divisor in CD5.
(e₁ - e₁₄) × (e₃ - e₁₂) = 0 and (e₃ - e₁₂) × (e₁ - e₁₄) = 0.
-/
theorem Pattern4_CD5 : IsBilateralZeroDivisor (P4 5) (Q4 5) := by
  constructor <;> norm_cast

/-
Pattern 1 is a bilateral zero divisor in CD6 (64D chingons).
(e₁ + e₁₄) × (e₃ + e₁₂) = 0 and (e₃ + e₁₂) × (e₁ + e₁₄) = 0.
-/
theorem Pattern1_CD6 : IsBilateralZeroDivisor (P1 6) (Q1 6) := by
  constructor <;> norm_cast

/-
Pattern 5 is a bilateral zero divisor in CD5.
(e₁ - e₁₄) × (e₅ + e₁₀) = 0 and (e₅ + e₁₀) × (e₁ - e₁₄) = 0.
-/
theorem Pattern5_CD5 : IsBilateralZeroDivisor (P5 5) (Q5 5) := by
  constructor <;> norm_cast

/-
Pattern 2 is a bilateral zero divisor in CD6.
(e₃ + e₁₂) × (e₅ + e₁₀) = 0 and (e₅ + e₁₀) × (e₃ + e₁₂) = 0.
-/
theorem Pattern2_CD6 : IsBilateralZeroDivisor (P2 6) (Q2 6) := by
  constructor <;> norm_cast

/-
Vanishing commutator for Pattern 1 in CD4, CD5, and CD6.
[P1, Q1] = 0.
-/
theorem Bracket_Pattern1_CD4 : bracket (P1 4) (Q1 4) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern1_CD4

theorem Bracket_Pattern1_CD5 : bracket (P1 5) (Q1 5) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern1_CD5

theorem Bracket_Pattern1_CD6 : bracket (P1 6) (Q1 6) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern1_CD6

/-
Pattern 6 is a bilateral zero divisor in CD5.
(e₂ - e₁₃) × (e₆ + e₉) = 0 and (e₆ + e₉) × (e₂ - e₁₃) = 0.
-/
theorem Pattern6_CD5 : IsBilateralZeroDivisor (P6 5) (Q6 5) := by
  constructor <;> norm_cast

/-
Pattern 3 is a bilateral zero divisor in CD6.
(e₄ + e₁₁) × (e₆ + e₉) = 0 and (e₆ + e₉) × (e₄ + e₁₁) = 0.
-/
theorem Pattern3_CD6 : IsBilateralZeroDivisor (P3 6) (Q3 6) := by
  constructor <;> norm_cast

/-
Pattern 4 is a bilateral zero divisor in CD6.
(e₁ - e₁₄) × (e₃ - e₁₂) = 0 and (e₃ - e₁₂) × (e₁ - e₁₄) = 0.
-/
theorem Pattern4_CD6 : IsBilateralZeroDivisor (P4 6) (Q4 6) := by
  constructor <;> norm_cast

/-
Pattern 5 is a bilateral zero divisor in CD6.
(e₁ - e₁₄) × (e₅ + e₁₀) = 0 and (e₅ + e₁₀) × (e₁ - e₁₄) = 0.
-/
theorem Pattern5_CD6 : IsBilateralZeroDivisor (P5 6) (Q5 6) := by
  constructor <;> norm_cast

/-
Vanishing commutator for Pattern 2 in CD4, CD5, and CD6.
[P2, Q2] = 0.
-/
theorem Bracket_Pattern2_CD4 : bracket (P2 4) (Q2 4) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern2_CD4

theorem Bracket_Pattern2_CD5 : bracket (P2 5) (Q2 5) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern2_CD5

theorem Bracket_Pattern2_CD6 : bracket (P2 6) (Q2 6) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern2_CD6

/-
Vanishing commutator for Pattern 3 in CD4, CD5, and CD6.
[P3, Q3] = 0.
-/
theorem Bracket_Pattern3_CD4 : bracket (P3 4) (Q3 4) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern3_CD4

theorem Bracket_Pattern3_CD5 : bracket (P3 5) (Q3 5) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern3_CD5

theorem Bracket_Pattern3_CD6 : bracket (P3 6) (Q3 6) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern3_CD6

/-
Vanishing commutator for Pattern 4 in CD4, CD5, and CD6.
[P4, Q4] = 0.
-/
theorem Bracket_Pattern4_CD4 : bracket (P4 4) (Q4 4) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern4_CD4

theorem Bracket_Pattern4_CD5 : bracket (P4 5) (Q4 5) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern4_CD5

theorem Bracket_Pattern4_CD6 : bracket (P4 6) (Q4 6) = 0 :=
  bracket_eq_zero_of_bilateral_zero_divisor _ _ Pattern4_CD6

/-
Vanishing commutator for Pattern 5 in CD4. [P5, Q5] = 0.
-/
theorem Bracket_Pattern5_CD4 : bracket (P5 4) (Q5 4) = 0 := by
  -- Apply the lemma that states the commutator of a bilateral zero divisor is zero.
  apply bracket_eq_zero_of_bilateral_zero_divisor; exact Pattern5_CD4

/-
Vanishing commutator for Pattern 5 in CD5. [P5, Q5] = 0.
-/
theorem Bracket_Pattern5_CD5 : bracket (P5 5) (Q5 5) = 0 := by
  -- Apply the lemma that states if a and b are bilateral zero divisors, then their commutator is zero.
  apply bracket_eq_zero_of_bilateral_zero_divisor; exact Pattern5_CD5

/-
Vanishing commutator for Pattern 5 in CD6. [P5, Q5] = 0.
-/
theorem Bracket_Pattern5_CD6 : bracket (P5 6) (Q5 6) = 0 := by
  -- Apply the lemma that states the commutator of a bilateral zero divisor is zero.
  apply bracket_eq_zero_of_bilateral_zero_divisor; exact Pattern5_CD6

/-
Vanishing commutator for Pattern 6 in CD4. [P6, Q6] = 0.
-/
theorem Bracket_Pattern6_CD4 : bracket (P6 4) (Q6 4) = 0 := by
  -- Apply the lemma that states the commutator of a bilateral zero divisor is zero.
  apply bracket_eq_zero_of_bilateral_zero_divisor; exact Pattern6_CD4

/-
Vanishing commutator for Pattern 6 in CD5. [P6, Q6] = 0.
-/
theorem Bracket_Pattern6_CD5 : bracket (P6 5) (Q6 5) = 0 := by
  -- Apply the lemma that states the commutator of a bilateral zero divisor is zero.
  apply bracket_eq_zero_of_bilateral_zero_divisor; exact Pattern6_CD5

/-
Vanishing commutator for Pattern 6 in CD6. [P6, Q6] = 0.
-/
theorem Bracket_Pattern6_CD6 : bracket (P6 6) (Q6 6) = 0 := by
  apply bracket_eq_zero_of_bilateral_zero_divisor;
  constructor <;> norm_cast

/-
If a and b are bilateral zero divisors in CD n, then their embeddings (a, 0) and (b, 0) are bilateral zero divisors in CD (n+1).
-/
lemma lift_bilateral_zero_divisor (n : Nat) (a b : CD n) : IsBilateralZeroDivisor a b → IsBilateralZeroDivisor (a, 0) (b, 0) := by
  intro h
  unfold IsBilateralZeroDivisor at h ⊢
  simp_all +decide [ mul_comm, mul_assoc, mul_left_comm ]

/-
Helper lemma: e (n+1) k lifts to (e n k, 0) if k < 2^n.
-/
lemma e_lift (n : Nat) (k : Nat) (h : k < 2^n) : e (n + 1) k = (e n k, 0) := by
  exact if_pos h

/-
P6 6 is the lifting of P6 5.
-/
lemma P6_lift : P6 6 = (P6 5, 0) := by
  exact Prod.ext rfl ( sub_zero _ )

/-
Q6 6 is the lifting of Q6 5.
-/
lemma Q6_lift : Q6 6 = (Q6 5, 0) := by
  unfold Q6; norm_cast