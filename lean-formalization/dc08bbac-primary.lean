/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dc08bbac-9ffd-4e17-82c3-37088ebb4a92

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Star

#synth Star ℚ

#eval (star (1/2 : ℚ))

/-
Definition of Cayley-Dickson construction and instances for basic operations. Also defines Star instance for Rationals.
-/
structure CayleyDickson (A : Type) where
  re : A
  im : A
  deriving DecidableEq, Repr

instance {A : Type} [Add A] : Add (CayleyDickson A) where
  add x y := ⟨x.re + y.re, x.im + y.im⟩

instance {A : Type} [Neg A] : Neg (CayleyDickson A) where
  neg x := ⟨-x.re, -x.im⟩

instance {A : Type} [Zero A] : Zero (CayleyDickson A) where
  zero := ⟨0, 0⟩

instance {A : Type} [One A] [Zero A] : One (CayleyDickson A) where
  one := ⟨1, 0⟩

instance {A : Type} [Sub A] : Sub (CayleyDickson A) where
  sub x y := ⟨x.re - y.re, x.im - y.im⟩

instance {A : Type} [Star A] [Neg A] : Star (CayleyDickson A) where
  star x := ⟨star x.re, -x.im⟩

instance {A : Type} [Add A] [Mul A] [Sub A] [Star A] : Mul (CayleyDickson A) where
  mul x y := ⟨x.re * y.re - star y.im * x.im, y.im * x.re + x.im * star y.re⟩

instance {A : Type} [SMul ℚ A] : SMul ℚ (CayleyDickson A) where
  smul r x := ⟨r • x.re, r • x.im⟩

instance {A : Type} [Coe ℚ A] [Zero A] : Coe ℚ (CayleyDickson A) where
  coe r := ⟨r, 0⟩

instance : Star ℚ where
  star x := x

instance : TrivialStar ℚ where
  star_trivial x := rfl

/-
Definitions of Cayley-Dickson algebras CD0 to CD4 and their basis elements.
-/
abbrev CD0 := ℚ
abbrev CD1 := CayleyDickson CD0
abbrev CD2 := CayleyDickson CD1
abbrev CD3 := CayleyDickson CD2
abbrev CD4 := CayleyDickson CD3

def basis0 (n : Nat) : CD0 := if n == 0 then 1 else 0

def lift {A : Type} [Zero A] (basis_A : Nat → A) (dim_A : Nat) (n : Nat) : CayleyDickson A :=
  if n < dim_A then ⟨basis_A n, 0⟩ else ⟨0, basis_A (n - dim_A)⟩

def basis1 : Nat → CD1 := lift basis0 1
def basis2 : Nat → CD2 := lift basis1 2
def basis3 : Nat → CD3 := lift basis2 4
def basis4 : Nat → CD4 := lift basis3 8

def e (n : Nat) : CD4 := basis4 n

/-
Verification of Pattern 18 in Cayley-Dickson Sedenions: (e₁ + e₁₄) × (e₃ + e₁₂) = 0
-/
theorem pattern_18 : (e 1 + e 14) * (e 3 + e 12) = 0 := by
  decide +kernel

/-
Verification of Pattern 59 in Cayley-Dickson Sedenions: (e₃ + e₁₂) × (e₅ + e₁₀) = 0
-/
theorem pattern_59 : (e 3 + e 12) * (e 5 + e 10) = 0 := by
  decide +kernel

/-
Verification of Pattern 84 in Cayley-Dickson Sedenions: (e₄ + e₁₁) × (e₆ + e₉) = 0
-/
theorem pattern_84 : (e 4 + e 11) * (e 6 + e 9) = 0 := by
  decide +kernel

/-
Verification of Pattern 102 in Cayley-Dickson Sedenions: (e₁ - e₁₄) × (e₃ - e₁₂) = 0
-/
theorem pattern_102 : (e 1 - e 14) * (e 3 - e 12) = 0 := by
  decide +kernel

/-
Verification of Pattern 104 in Cayley-Dickson Sedenions: (e₁ - e₁₄) × (e₅ + e₁₀) = 0
-/
theorem pattern_104 : (e 1 - e 14) * (e 5 + e 10) = 0 := by
  decide +kernel

/-
Verification of Pattern 124 in Cayley-Dickson Sedenions: (e₂ - e₁₃) × (e₆ + e₉) = 0
-/
theorem pattern_124 : (e 2 - e 13) * (e 6 + e 9) = 0 := by
  decide +kernel

/-
Verification of Pattern 19 in Cayley-Dickson Sedenions: (e₁ + e₁₄) × (e₄ - e₁₁) = 0
-/
theorem pattern_19 : (e 1 + e 14) * (e 4 - e 11) = 0 := by
  decide +kernel

/-
Verification of Pattern 58 in Cayley-Dickson Sedenions: (e₃ + e₁₂) × (e₂ - e₁₃) = 0
-/
theorem pattern_58 : (e 3 + e 12) * (e 2 - e 13) = 0 := by
  decide +kernel

/-
Verification of Pattern 81 in Cayley-Dickson Sedenions: (e₄ + e₁₁) × (e₁ - e₁₄) = 0
-/
theorem pattern_81 : (e 4 + e 11) * (e 1 - e 14) = 0 := by
  unfold e; norm_cast;

/-
Verification of Pattern 101 in Cayley-Dickson Sedenions: (e₁ - e₁₄) × (e₂ - e₁₃) = 0
-/
theorem pattern_101 : (e 1 - e 14) * (e 2 - e 13) = 0 := by
  decide +kernel

/-
Definitions of CD5 (Pathion) and CD6 (Chingon) and verification of Pattern 18 in these dimensions.
-/
abbrev CD5 := CayleyDickson CD4
abbrev CD6 := CayleyDickson CD5

def basis5 : Nat → CD5 := lift basis4 16
def basis6 : Nat → CD6 := lift basis5 32

def e5 (n : Nat) : CD5 := basis5 n
def e6 (n : Nat) : CD6 := basis6 n

theorem pattern_18_CD5 : (e5 1 + e5 14) * (e5 3 + e5 12) = 0 := by
  decide +kernel
theorem pattern_18_CD6 : (e6 1 + e6 14) * (e6 3 + e6 12) = 0 := by
  decide +kernel

/-
Verification of Patterns 59 and 84 in CD5 (Pathion) and CD6 (Chingon).
-/
theorem pattern_59_CD5 : (e5 3 + e5 12) * (e5 5 + e5 10) = 0 := by decide +kernel
theorem pattern_59_CD6 : (e6 3 + e6 12) * (e6 5 + e6 10) = 0 := by decide +kernel

theorem pattern_84_CD5 : (e5 4 + e5 11) * (e5 6 + e5 9) = 0 := by decide +kernel
theorem pattern_84_CD6 : (e6 4 + e6 11) * (e6 6 + e6 9) = 0 := by decide +kernel

#check QuadraticForm
#check CliffordAlgebra

#check QuadraticForm
#check QuadraticMap
#check QuadraticMap.weightedSumSquares
#check CliffordAlgebra

#check @QuadraticMap.weightedSumSquares

#print QuadraticForm
#synth Ring (CliffordAlgebra (0 : QuadraticForm ℚ (Fin 4 → ℚ)))

/-
Definitions of Q4, Cl4, Q5, Cl5 using abbrev to help typeclass synthesis.
-/
abbrev V4 := Fin 4 → ℚ
abbrev Q4 : QuadraticForm ℚ V4 := QuadraticMap.weightedSumSquares ℚ (fun (_ : Fin 4) => (1 : ℚ))
abbrev Cl4 := CliffordAlgebra Q4

abbrev V5 := Fin 5 → ℚ
abbrev Q5 : QuadraticForm ℚ V5 := QuadraticMap.weightedSumSquares ℚ (fun (_ : Fin 5) => (1 : ℚ))
abbrev Cl5 := CliffordAlgebra Q5

-- Verify Ring instances
example : Ring Cl4 := inferInstance
example : Ring Cl5 := inferInstance

/-
Definitions of basis elements for Cl4 and Cl5.
-/
open CliffordAlgebra

def e_cl4 (n : Nat) : Cl4 :=
  let indices := (List.finRange 4).filter (fun i => (n >>> i.val) % 2 = 1)
  indices.foldl (fun acc i => acc * ι Q4 (Pi.single i 1)) 1

def e_cl5 (n : Nat) : Cl5 :=
  let indices := (List.finRange 5).filter (fun i => (n >>> i.val) % 2 = 1)
  indices.foldl (fun acc i => acc * ι Q5 (Pi.single i 1)) 1

/-
Verification of Pattern 18 in Cl(4,0).
-/
theorem pattern_18_cl4 : (e_cl4 1 + e_cl4 14) * (e_cl4 3 + e_cl4 12) = 0 := by
  -- Let's simplify the multiplication step by step.
  have h_mul : (ι Q4 (Pi.single 0 1) + ι Q4 (Pi.single 1 1) * ι Q4 (Pi.single 2 1) * ι Q4 (Pi.single 3 1)) * (ι Q4 (Pi.single 0 1) * ι Q4 (Pi.single 1 1) + ι Q4 (Pi.single 2 1) * ι Q4 (Pi.single 3 1)) = 0 := by
    have h_mul : (ι Q4 (Pi.single 0 1)) * (ι Q4 (Pi.single 0 1)) = 1 ∧ (ι Q4 (Pi.single 1 1)) * (ι Q4 (Pi.single 1 1)) = 1 ∧ (ι Q4 (Pi.single 2 1)) * (ι Q4 (Pi.single 2 1)) = 1 ∧ (ι Q4 (Pi.single 3 1)) * (ι Q4 (Pi.single 3 1)) = 1 := by
      unfold Q4; norm_num [ Fin.sum_univ_succ, Pi.single_apply ] ;
    have h_mul : (ι Q4 (Pi.single 0 1)) * (ι Q4 (Pi.single 1 1)) = - (ι Q4 (Pi.single 1 1)) * (ι Q4 (Pi.single 0 1)) ∧ (ι Q4 (Pi.single 0 1)) * (ι Q4 (Pi.single 2 1)) = - (ι Q4 (Pi.single 2 1)) * (ι Q4 (Pi.single 0 1)) ∧ (ι Q4 (Pi.single 0 1)) * (ι Q4 (Pi.single 3 1)) = - (ι Q4 (Pi.single 3 1)) * (ι Q4 (Pi.single 0 1)) ∧ (ι Q4 (Pi.single 1 1)) * (ι Q4 (Pi.single 2 1)) = - (ι Q4 (Pi.single 2 1)) * (ι Q4 (Pi.single 1 1)) ∧ (ι Q4 (Pi.single 1 1)) * (ι Q4 (Pi.single 3 1)) = - (ι Q4 (Pi.single 3 1)) * (ι Q4 (Pi.single 1 1)) ∧ (ι Q4 (Pi.single 2 1)) * (ι Q4 (Pi.single 3 1)) = - (ι Q4 (Pi.single 3 1)) * (ι Q4 (Pi.single 2 1)) := by
      have h_mul : ∀ (i j : Fin 4), i ≠ j → (ι Q4 (Pi.single i 1)) * (ι Q4 (Pi.single j 1)) = - (ι Q4 (Pi.single j 1)) * (ι Q4 (Pi.single i 1)) := by
        intros i j hij;
        have h_mul : ∀ (i j : Fin 4), i ≠ j → (ι Q4 (Pi.single i 1)) * (ι Q4 (Pi.single j 1)) + (ι Q4 (Pi.single j 1)) * (ι Q4 (Pi.single i 1)) = 0 := by
          intros i j hij;
          have := CliffordAlgebra.ι_sq_scalar Q4 ( Pi.single i 1 + Pi.single j 1 );
          simp_all +decide [ add_mul, mul_add, ← mul_assoc ];
          simp_all +decide [ Finset.sum_add_distrib, mul_comm ];
          simp_all +decide [ Finset.sum_apply, Pi.single_apply ];
          split_ifs at this <;> simp_all +decide [ add_comm, add_left_comm, add_assoc ];
        simpa [ neg_mul ] using eq_neg_of_add_eq_zero_left ( h_mul i j hij );
      exact ⟨ h_mul 0 1 ( by decide ), h_mul 0 2 ( by decide ), h_mul 0 3 ( by decide ), h_mul 1 2 ( by decide ), h_mul 1 3 ( by decide ), h_mul 2 3 ( by decide ) ⟩;
    simp_all +decide [ mul_add, add_mul, mul_assoc ];
    simp_all +decide [ ← mul_assoc ];
    simp_all +decide [ mul_assoc, add_assoc, add_left_comm, add_comm ];
  convert h_mul using 1;
  unfold e_cl4;
  simp +decide [ List.finRange ]

/-
Defining `v` as the basis vectors of `Cl4` and proving that `v i * v i = 1`.
-/
open CliffordAlgebra

abbrev v (i : Fin 4) : Cl4 := ι Q4 (Pi.single i 1)

lemma v_sq (i : Fin 4) : v i * v i = 1 := by
  fin_cases i <;> simp +decide [ Fin.sum_univ_succ ]

/-
Proving the anticommutation relation for basis vectors: v_i * v_j = - v_j * v_i for i != j.
-/
lemma v_anticomm (i j : Fin 4) (h : i ≠ j) : v i * v j = - (v j * v i) := by
  -- By definition of Clifford algebra, we know that $v_i v_j + v_j v_i = 0$ for $i \neq j$.
  have h_anticomm : ∀ i j : Fin 4, i ≠ j → v i * v j + v j * v i = 0 := by
    intros i j hij
    have h_anticomm : v i * v j + v j * v i = ι Q4 (Pi.single i 1 + Pi.single j 1) * ι Q4 (Pi.single i 1 + Pi.single j 1) - ι Q4 (Pi.single i 1) * ι Q4 (Pi.single i 1) - ι Q4 (Pi.single j 1) * ι Q4 (Pi.single j 1) := by
      simp +decide [ add_mul, mul_add, sub_mul, mul_sub ];
      grind +ring;
    rw [ h_anticomm, ← sq, ← sq, ← sq ];
    rw [ sq, sq, sq, CliffordAlgebra.ι_sq_scalar, CliffordAlgebra.ι_sq_scalar, CliffordAlgebra.ι_sq_scalar ];
    simp +decide [ Fin.sum_univ_four, Pi.single_apply ];
    fin_cases i <;> fin_cases j <;> simp +decide at hij ⊢;
  exact eq_neg_of_add_eq_zero_left <| h_anticomm i j h

/-
Verification of Pattern 18 in Cl(4,0) using helper lemmas.
-/
theorem pattern_18_cl4_verified : (e_cl4 1 + e_cl4 14) * (e_cl4 3 + e_cl4 12) = 0 := by
  exact?

/-
Verification of Pattern 59 in Cl(4,0).
-/
theorem pattern_59_cl4 : (e_cl4 3 + e_cl4 12) * (e_cl4 5 + e_cl4 10) = 0 := by
  -- Now use the definitions of `e_cl4` and the properties of `v` to expand the product.
  have h_expand : (e_cl4 3 + e_cl4 12) * (e_cl4 5 + e_cl4 10) = (v 0 * v 1 + v 2 * v 3) * (v 0 * v 2 + v 1 * v 3) := by
    unfold e_cl4;
    simp +decide [ List.finRange, List.filter_cons ];
  rw [ h_expand ];
  -- Let's simplify the expression using the properties of the vectors.
  -- Notice that $v_i * v_i = 1$ and $v_i * v_j = -v_j * v_i$ for $i \ne j$.
  have h_simplify : v 0 * v 0 = 1 ∧ v 1 * v 1 = 1 ∧ v 2 * v 2 = 1 ∧ v 3 * v 3 = 1 ∧ v 0 * v 1 = -v 1 * v 0 ∧ v 0 * v 2 = -v 2 * v 0 ∧ v 0 * v 3 = -v 3 * v 0 ∧ v 1 * v 2 = -v 2 * v 1 ∧ v 1 * v 3 = -v 3 * v 1 ∧ v 2 * v 3 = -v 3 * v 2 := by
    have h_simplify : v 0 * v 0 = 1 ∧ v 1 * v 1 = 1 ∧ v 2 * v 2 = 1 ∧ v 3 * v 3 = 1 := by
      exact ⟨ v_sq 0, v_sq 1, v_sq 2, v_sq 3 ⟩;
    have h_anticomm : ∀ i j : Fin 4, i ≠ j → v i * v j = -v j * v i := by
      simp +zetaDelta at *;
      exact?;
    exact ⟨ h_simplify.1, h_simplify.2.1, h_simplify.2.2.1, h_simplify.2.2.2, h_anticomm 0 1 ( by decide ), h_anticomm 0 2 ( by decide ), h_anticomm 0 3 ( by decide ), h_anticomm 1 2 ( by decide ), h_anticomm 1 3 ( by decide ), h_anticomm 2 3 ( by decide ) ⟩;
  simp +decide [ mul_add, add_mul, mul_assoc, h_simplify ];
  simp +decide [ ← mul_assoc, h_simplify ];
  simp_all +decide [ mul_assoc, add_eq_zero_iff_eq_neg ];
  simp_all +decide [ ← mul_assoc ]

/-
Verification of Pattern 84 in Cl(4,0).
-/
theorem pattern_84_cl4 : (e_cl4 4 + e_cl4 11) * (e_cl4 6 + e_cl4 9) = 0 := by
  unfold e_cl4;
  norm_num [ List.finRange, List.filter_cons ];
  have := v_anticomm 0 1 ( by decide ) ; have := v_anticomm 0 2 ( by decide ) ; have := v_anticomm 0 3 ( by decide ) ; have := v_anticomm 1 2 ( by decide ) ; have := v_anticomm 1 3 ( by decide ) ; have := v_anticomm 2 3 ( by decide ) ; simp_all +decide [ mul_assoc ] ;
  simp_all +decide [ mul_add, add_mul ];
  simp_all +decide [ mul_assoc, ← eq_sub_iff_add_eq' ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_succ, mul_assoc ];
  simp_all +decide [ ← mul_assoc ];
  simp +decide [ Fin.sum_univ_succ, Pi.single_apply ]

/-
Verification of Pattern 59 in Cl(4,0).
-/
theorem pattern_59_cl4_verified : (e_cl4 3 + e_cl4 12) * (e_cl4 5 + e_cl4 10) = 0 := by
  exact?

/-
Verification of Pattern 102 in Cl(4,0).
-/
theorem pattern_102_cl4_verified : (e_cl4 1 - e_cl4 14) * (e_cl4 3 - e_cl4 12) = 0 := by
  -- Using the definitions of `e_cl4`, we can expand the product.
  simp (config := { decide := true }) only [mul_sub, sub_mul];
  -- By expanding each term using the definitions of `e_cl4`, we can simplify the expression.
  have h_expand : e_cl4 1 = v 0 ∧ e_cl4 3 = v 0 * v 1 ∧ e_cl4 12 = v 2 * v 3 ∧ e_cl4 14 = v 1 * v 2 * v 3 := by
    -- By definition of `e_cl4`, we can expand each term using the binary representation of the index.
    simp [e_cl4, v];
    simp +decide [ List.finRange ];
  -- Apply the anticommutation relations to each term.
  have h_anticomm : v 1 * v 0 = -v 0 * v 1 ∧ v 2 * v 1 = -v 1 * v 2 ∧ v 3 * v 1 = -v 1 * v 3 ∧ v 2 * v 0 = -v 0 * v 2 ∧ v 3 * v 0 = -v 0 * v 3 ∧ v 3 * v 2 = -v 2 * v 3 := by
    simp +zetaDelta at *;
    exact ⟨ by rw [ v_anticomm 1 0 ( by decide ) ], by rw [ v_anticomm 2 1 ( by decide ) ], by rw [ v_anticomm 3 1 ( by decide ) ], by rw [ v_anticomm 2 0 ( by decide ) ], by rw [ v_anticomm 3 0 ( by decide ) ], by rw [ v_anticomm 3 2 ( by decide ) ] ⟩;
  simp_all +decide [ mul_assoc, mul_left_comm ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_succ, mul_assoc ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_succ, mul_assoc ];
  abel1

/-
Verification of Pattern 84 in Cl(4,0).
-/
theorem pattern_84_cl4_verified : (e_cl4 4 + e_cl4 11) * (e_cl4 6 + e_cl4 9) = 0 := by
  exact?

/-
Helper lemmas expanding `e_cl4` for specific indices into products of basis vectors `v`.
-/
lemma e_cl4_1 : e_cl4 1 = v 0 := by
  -- By definition of `e_cl4`, we have `e_cl4 1 = v 0`.
  simp [e_cl4];
  simp +decide [ List.finRange, List.filter_cons ]

lemma e_cl4_2 : e_cl4 2 = v 1 := by
  unfold e_cl4;
  simp +decide [ List.finRange ]

lemma e_cl4_3 : e_cl4 3 = v 0 * v 1 := by
  -- By definition of `e_cl4`, we can see that `e_cl4 3` corresponds to the product of `v 0` and `v 1`.
  simp [e_cl4, List.finRange, List.filter];
  simp +decide [ Nat.testBit ]

lemma e_cl4_4 : e_cl4 4 = v 2 := by
  unfold e_cl4; norm_num [ List.finRange, List.filter_cons, List.filter_nil ] ;
  simp +decide [ v ]

lemma e_cl4_5 : e_cl4 5 = v 0 * v 2 := by
  unfold e_cl4; norm_num [ v ] ; ring;
  simp +decide [ List.finRange ]

lemma e_cl4_6 : e_cl4 6 = v 1 * v 2 := by
  -- By definition of $e_cl4$, we can write $e_cl4 6$ as $v 1 * v 2$.
  simp [e_cl4, v];
  simp +decide [ List.foldl, List.finRange ]

lemma e_cl4_9 : e_cl4 9 = v 0 * v 3 := by
  unfold e_cl4;
  simp +decide [ List.finRange, List.filter_cons ]

lemma e_cl4_10 : e_cl4 10 = v 1 * v 3 := by
  -- Let's compute the product of v 1 and v 3 using the definition of e_cl4.
  simp [e_cl4];
  simp +decide [ List.finRange, v ]

lemma e_cl4_11 : e_cl4 11 = v 0 * v 1 * v 3 := by
  unfold e_cl4;
  simp +decide [ List.finRange, v ]

lemma e_cl4_12 : e_cl4 12 = v 2 * v 3 := by
  unfold e_cl4 v; simp +decide [ mul_assoc, List.foldl ] ;
  simp +decide [ List.finRange, List.filter ];
  simp +decide [ Nat.testBit ]

lemma e_cl4_13 : e_cl4 13 = v 0 * v 2 * v 3 := by
  unfold e_cl4;
  simp +decide [ List.finRange ]

lemma e_cl4_14 : e_cl4 14 = v 1 * v 2 * v 3 := by
  simp +decide [ e_cl4, List.finRange ]

/-
Verification of Pattern 104 in Cl(4,0).
-/
theorem pattern_104_cl4_verified : (e_cl4 1 - e_cl4 14) * (e_cl4 5 + e_cl4 10) = 0 := by
  -- Expand `e_cl4` in terms of `v` and simplify the expression.
  have h_expand : (e_cl4 1 - e_cl4 14) * (e_cl4 5 + e_cl4 10) = (v 0 - v 1 * v 2 * v 3) * (v 0 * v 2 + v 1 * v 3) := by
    rw [ show e_cl4 1 = v 0 from e_cl4_1, show e_cl4 14 = v 1 * v 2 * v 3 from e_cl4_14, show e_cl4 5 = v 0 * v 2 from e_cl4_5, show e_cl4 10 = v 1 * v 3 from e_cl4_10 ];
  simp_all +decide [ mul_assoc, sub_mul, mul_sub ];
  -- Apply the anticommutation relations to simplify the expression.
  have h_anticomm : v 0 * v 1 = -v 1 * v 0 ∧ v 0 * v 2 = -v 2 * v 0 ∧ v 0 * v 3 = -v 3 * v 0 ∧ v 1 * v 2 = -v 2 * v 1 ∧ v 1 * v 3 = -v 3 * v 1 ∧ v 2 * v 3 = -v 3 * v 2 := by
    exact ⟨ by simpa using v_anticomm 0 1 ( by decide ), by simpa using v_anticomm 0 2 ( by decide ), by simpa using v_anticomm 0 3 ( by decide ), by simpa using v_anticomm 1 2 ( by decide ), by simpa using v_anticomm 1 3 ( by decide ), by simpa using v_anticomm 2 3 ( by decide ) ⟩;
  simp +decide [ h_anticomm, mul_add, add_mul, mul_assoc, mul_left_comm ];
  simp +decide [ ← mul_assoc, h_anticomm ];
  simp +decide [ Fin.sum_univ_four, mul_assoc, h_anticomm ];
  simp +decide [ ← mul_assoc, h_anticomm ];
  simp +decide [ Fin.sum_univ_four, Pi.single_apply ];
  grind

/-
Verification of Pattern 124 in Cl(4,0).
-/
theorem pattern_124_cl4_verified : (e_cl4 2 - e_cl4 13) * (e_cl4 6 + e_cl4 9) = 0 := by
  -- Expand the product using the definitions of `e_cl4`.
  simp [e_cl4_2, e_cl4_13, e_cl4_6, e_cl4_9];
  -- Expand the product using the distributive property.
  simp [mul_add, add_mul, sub_mul, mul_sub];
  -- Apply the anticommutation relations to simplify the expression.
  have h_anticomm : v 1 * v 0 = -v 0 * v 1 ∧ v 1 * v 2 = -v 2 * v 1 ∧ v 1 * v 3 = -v 3 * v 1 ∧ v 2 * v 0 = -v 0 * v 2 ∧ v 2 * v 3 = -v 3 * v 2 ∧ v 3 * v 0 = -v 0 * v 3 := by
    apply_rules [ And.intro ];
    all_goals rw [ neg_mul ] ; exact v_anticomm _ _ <| by decide;
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ mul_assoc, v_sq ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_four, mul_assoc ];
  abel1

/-
Verification of Pattern 18 in Cl(5,0).
-/
theorem pattern_18_cl5 : (e_cl5 1 + e_cl5 14) * (e_cl5 3 + e_cl5 12) = 0 := by
  -- By definition of $e_cl5$, we can expand each term in the product.
  have h_expand : e_cl5 1 = ι Q5 (Pi.single 0 1) ∧ e_cl5 14 = ι Q5 (Pi.single 1 1) * ι Q5 (Pi.single 2 1) * ι Q5 (Pi.single 3 1) := by
    unfold e_cl5;
    simp +decide [ List.finRange ];
  -- By definition of $e_cl5$, we can expand each term in the product for $e_cl5 3$ and $e_cl5 12$.
  have h_expand_3 : e_cl5 3 = ι Q5 (Pi.single 0 1) * ι Q5 (Pi.single 1 1) := by
    unfold e_cl5; simp +decide [ List.finRange ] ;
  have h_expand_12 : e_cl5 12 = ι Q5 (Pi.single 2 1) * ι Q5 (Pi.single 3 1) := by
    unfold e_cl5; simp +decide [ List.finRange ] ;
  simp_all +decide [ mul_assoc, mul_add, mul_comm, mul_left_comm ];
  -- By definition of $v$, we know that $v_i * v_j = - v_j * v_i$ for $i \ne j$.
  have h_anticomm : ∀ i j : Fin 5, i ≠ j → ι Q5 (Pi.single i 1) * ι Q5 (Pi.single j 1) = -ι Q5 (Pi.single j 1) * ι Q5 (Pi.single i 1) := by
    intros i j hij;
    have h_anticomm : ∀ i j : Fin 5, i ≠ j → ι Q5 (Pi.single i 1 + Pi.single j 1) * ι Q5 (Pi.single i 1 + Pi.single j 1) = ι Q5 (Pi.single i 1) * ι Q5 (Pi.single i 1) + ι Q5 (Pi.single j 1) * ι Q5 (Pi.single j 1) := by
      intros i j hij
      have h_anticomm : Q5 (Pi.single i 1 + Pi.single j 1) = Q5 (Pi.single i 1) + Q5 (Pi.single j 1) := by
        native_decide +revert;
      have := CliffordAlgebra.ι_sq_scalar Q5 ( Pi.single i 1 + Pi.single j 1 ) ; aesop;
    have := h_anticomm i j hij; simp_all +decide [ mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm ] ;
    grind;
  -- By definition of $v$, we know that $v_i^2 = 1$ for all $i$.
  have h_sq : ∀ i : Fin 5, ι Q5 (Pi.single i 1) * ι Q5 (Pi.single i 1) = 1 := by
    intro i; exact (by
    fin_cases i <;> simp +decide [ Fin.sum_univ_succ ]);
  simp +decide [ add_mul, mul_assoc, h_sq ];
  simp +decide [ ← mul_assoc, h_anticomm 0 1 ( by decide ), h_anticomm 0 2 ( by decide ), h_anticomm 0 3 ( by decide ), h_anticomm 1 2 ( by decide ), h_anticomm 1 3 ( by decide ), h_anticomm 2 3 ( by decide ), h_sq ];
  simp +decide [ mul_assoc, h_anticomm 0 1 ( by decide ), h_anticomm 0 2 ( by decide ), h_anticomm 0 3 ( by decide ), h_anticomm 1 2 ( by decide ), h_anticomm 1 3 ( by decide ), h_anticomm 2 3 ( by decide ), h_sq ];
  abel1

/-
Expansion of Pattern 19 product in Cl(4,0).
-/
lemma pattern_19_expansion : (e_cl4 1 + e_cl4 14) * (e_cl4 4 - e_cl4 11) = 2 • (v 0 * v 2) - 2 • (v 1 * v 3) := by
  rw [ e_cl4_1, e_cl4_4, e_cl4_11 ];
  rw [ e_cl4_14 ] ; ring;
  simp_all +decide [ sub_eq_add_neg, add_mul, mul_add, mul_assoc, two_mul ];
  have := v_sq 0; ( have := v_sq 1; ( have := v_sq 2; ( have := v_sq 3; ( have := v_anticomm 0 1; ( have := v_anticomm 0 2; ( have := v_anticomm 0 3; ( have := v_anticomm 1 2; ( have := v_anticomm 1 3; ( have := v_anticomm 2 3; simp_all +decide ; ) ) ) ) ) ) ) ) );
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ mul_assoc, v_sq ];
  simp_all +decide [ ← mul_assoc ];
  abel1

/-
Expansion of Pattern 58 product in Cl(4,0).
-/
lemma pattern_58_expansion : (e_cl4 3 + e_cl4 12) * (e_cl4 2 - e_cl4 13) = 2 • (v 0) + 2 • (v 1 * v 2 * v 3) := by
  -- Expand the product using the definitions of `e_cl4`.
  simp [e_cl4_3, e_cl4_12, e_cl4_2, e_cl4_13];
  simp +decide [ mul_sub, add_mul, mul_assoc ];
  -- Apply the anticommutation relations to simplify the expression.
  have h_anticomm : v 0 * v 1 = -v 1 * v 0 ∧ v 0 * v 2 = -v 2 * v 0 ∧ v 0 * v 3 = -v 3 * v 0 ∧ v 1 * v 2 = -v 2 * v 1 ∧ v 1 * v 3 = -v 3 * v 1 ∧ v 2 * v 3 = -v 3 * v 2 := by
    -- Apply the anticommutation relation to each pair.
    have h_anticomm : ∀ i j : Fin 4, i ≠ j → v i * v j = -v j * v i := by
      intros i j hij; exact (by
      have := v_anticomm i j hij;
      rw [ this, neg_mul ]);
    exact ⟨ h_anticomm 0 1 ( by decide ), h_anticomm 0 2 ( by decide ), h_anticomm 0 3 ( by decide ), h_anticomm 1 2 ( by decide ), h_anticomm 1 3 ( by decide ), h_anticomm 2 3 ( by decide ) ⟩;
  simp +decide [ ← mul_assoc, h_anticomm ];
  simp +decide [ Fin.sum_univ_four, mul_assoc, h_anticomm ];
  simp +decide [ ← mul_assoc, ← two_mul, v_sq ];
  norm_num [ Fin.sum_univ_succ, two_mul, add_mul, mul_assoc ];
  simp +decide [ Fin.ext_iff, Pi.single_apply ];
  abel1

/-
Verification that Pattern 58 fails (is non-zero) in Cl(4,0).
-/
theorem pattern_58_cl4_fails : (e_cl4 3 + e_cl4 12) * (e_cl4 2 - e_cl4 13) ≠ 0 := by
  -- Using `pattern_58_expansion`, the expression simplifies to `2 • v 0 + 2 • (v 1 * v 2 * v 3)`.
  -- Suppose this is 0. Then `2 • v 0 = - 2 • (v 1 * v 2 * v 3)`.
  -- Since characteristic is 0, `v 0 = - v 1 * v 2 * v 3`.
  -- In the Clifford algebra `Cl(4,0)`, `v 0` corresponds to basis element `{0}` and `v 1 * v 2 * v 3` corresponds to basis element `{1, 2, 3}`.
  -- These are distinct basis elements, so they are linearly independent.
  -- Thus `v 0 ≠ - v 1 * v 2 * v 3`, so the expression is non-zero.
  have h_nonzero : (pattern_58_expansion : (e_cl4 3 + e_cl4 12) * (e_cl4 2 - e_cl4 13) = 2 • (v 0) + 2 • (v 1 * v 2 * v 3)) → ¬ (2 • (v 0) + 2 • (v 1 * v 2 * v 3) = 0) := by
    intro h_nonzero_eq
    by_contra h_contra
    have h_eq : v 0 = -v 1 * v 2 * v 3 := by
      have h_eq : 2 • (v 0) = -2 • (v 1 * v 2 * v 3) := by
        exact eq_neg_of_add_eq_zero_left h_contra ▸ by norm_num [ two_smul ] ;
      have h_eq : (2 : ℚ) • (v 0) = (2 : ℚ) • (-v 1 * v 2 * v 3) := by
        convert h_eq using 1 ; norm_num [ two_smul ];
      exact smul_right_injective _ two_ne_zero h_eq;
    have := h_eq ▸ v_sq 0; simp_all +decide [ ← mul_assoc, ← v_anticomm ] ;
    have h_contra : v 2 * v 1 * v 3 * v 2 * v 1 * v 3 = -1 := by
      have := v_anticomm 2 1 ( by decide ) ; ( have := v_anticomm 3 2 ( by decide ) ; ( have := v_anticomm 3 1 ( by decide ) ; simp_all +decide [ mul_assoc ] ; ) );
      simp_all +decide [ ← mul_assoc, Fin.sum_univ_four ];
    norm_num [ h_contra ] at this;
    rw [ neg_eq_iff_add_eq_zero ] at this;
    simp_all +decide [ ← two_smul ℚ, smul_eq_zero ];
  contrapose! h_nonzero;
  exact ⟨ pattern_58_expansion, h_nonzero ▸ pattern_58_expansion.symm ▸ rfl ⟩

/-
Expansion of Pattern 81 product in Cl(4,0).
-/
lemma pattern_81_expansion : (e_cl4 4 + e_cl4 11) * (e_cl4 1 - e_cl4 14) = 2 • (v 1 * v 3) - 2 • (v 0 * v 2) := by
  simp +decide [ e_cl4_1, e_cl4_4, e_cl4_11, e_cl4_14 ];
  simp +decide only [mul_assoc, mul_sub, add_mul];
  -- Apply the anticommutation relations to simplify the expression.
  have h_anticomm : v 2 * v 0 = -v 0 * v 2 ∧ v 0 * v 1 = -v 1 * v 0 ∧ v 1 * v 2 = -v 2 * v 1 ∧ v 2 * v 3 = -v 3 * v 2 ∧ v 0 * v 3 = -v 3 * v 0 ∧ v 1 * v 3 = -v 3 * v 1 := by
    exact ⟨ by simpa only [ neg_mul ] using v_anticomm 2 0 ( by decide ), by simpa only [ neg_mul ] using v_anticomm 0 1 ( by decide ), by simpa only [ neg_mul ] using v_anticomm 1 2 ( by decide ), by simpa only [ neg_mul ] using v_anticomm 2 3 ( by decide ), by simpa only [ neg_mul ] using v_anticomm 0 3 ( by decide ), by simpa only [ neg_mul ] using v_anticomm 1 3 ( by decide ) ⟩;
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_four, mul_assoc ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_four, mul_assoc ];
  grind

/-
Lemma stating that v1*v3 is not equal to v0*v2.
-/
lemma v1_v3_ne_v0_v2 : v 1 * v 3 ≠ v 0 * v 2 := by
  -- Multiply both sides by `v 0` on the left and `v 2` on the right.
  by_contra h_contra
  have h_eq : v 0 * v 1 * v 3 * v 2 = v 0 * v 0 * v 2 * v 2 := by
    simp +decide only [mul_assoc, h_contra];
  -- Simplify both sides using the fact that $v_i * v_i = 1$ and the anticommutation relations.
  have h_simp' : v 1 * v 3 * v 2 = -v 0 := by
    have h_simp' : v 1 * v 3 * v 2 = v 1 * (v 3 * v 2) := by
      rw [ mul_assoc ];
    rw [ h_simp', v_anticomm ] <;> norm_num;
    · rw [ ← mul_assoc, v_anticomm ] <;> norm_num;
      · rw [ mul_assoc, h_contra ];
        rw [ ← mul_assoc, v_anticomm ] <;> norm_num;
        · rw [ mul_assoc, v_sq ] ; norm_num;
        · decide +revert;
      · decide;
    · decide;
  apply_fun ( fun x => x * v 0 ) at h_simp' ; simp_all +decide [ mul_assoc ];
  simp +decide [ Fin.sum_univ_four, Fin.prod_univ_four, mul_assoc, v_sq ] at h_simp';
  rw [ eq_neg_iff_add_eq_zero ] at h_simp';
  simp_all +decide [ ← two_smul ℚ, smul_smul ]

/-
Expansion of Pattern 101 product in Cl(4,0).
-/
lemma pattern_101_expansion : (e_cl4 1 - e_cl4 14) * (e_cl4 2 - e_cl4 13) = 2 • (v 0 * v 1) - 2 • (v 2 * v 3) := by
  rw [ e_cl4_1, e_cl4_2, e_cl4_13, e_cl4_14 ];
  rw [ sub_mul ];
  norm_num [ mul_sub, ← mul_assoc, v_sq ] ; ring;
  have h_v0v1 : v 0 * v 1 = -v 1 * v 0 := by
    have := @v_anticomm 0 1 ( by decide );
    rw [ this, neg_mul ]
  have h_v1v2 : v 1 * v 2 = -v 2 * v 1 := by
    convert v_anticomm 1 2 ( by decide ) using 1;
    exact?
  have h_v2v3 : v 2 * v 3 = -v 3 * v 2 := by
    convert v_anticomm 2 3 ( by decide ) using 1;
    norm_num [ neg_mul ]
  have h_v0v2 : v 0 * v 2 = -v 2 * v 0 := by
    convert v_anticomm 0 2 ( by decide ) using 1;
    norm_num
  have h_v0v3 : v 0 * v 3 = -v 3 * v 0 := by
    convert v_anticomm 0 3 ( by decide ) using 1;
    norm_num [ neg_mul ]
  have h_v1v3 : v 1 * v 3 = -v 3 * v 1 := by
    convert v_anticomm 1 3 ( by decide ) using 1;
    norm_num;
  simp_all +decide [ mul_assoc, sub_eq_add_neg ];
  simp_all +decide [ ← mul_assoc, Fin.sum_univ_succ ];
  grind

/-
Verification that Pattern 101 fails (is non-zero) in Cl(4,0).
-/
theorem pattern_101_cl4_fails : (e_cl4 1 - e_cl4 14) * (e_cl4 2 - e_cl4 13) ≠ 0 := by
  by_contra h_contra;
  -- Using `pattern_101_expansion`, the expression simplifies to `2 • (v 0 * v 1) - 2 • (v 2 * v 3)`.
  have h_simp : 2 • (v 0 * v 1) - 2 • (v 2 * v 3) = 0 := by
    rw [ ← pattern_101_expansion, h_contra ];
  -- Since characteristic is 0, `v 0 * v 1 = v 2 * v 3`.
  have h_eq : v 0 * v 1 = v 2 * v 3 := by
    rw [ sub_eq_zero ] at h_simp;
    exact smul_right_injective _ two_ne_zero h_simp;
  -- In the Clifford algebra `Cl(Q4)`, `v 0 * v 1` corresponds to basis element `{0, 1}` and `v 2 * v 3` corresponds to basis element `{2, 3}`.
  -- These are distinct basis elements, so they are linearly independent.
  have h_lin_indep : ¬(v 0 * v 1 = v 2 * v 3) := by
    convert v1_v3_ne_v0_v2 using 1;
    constructor <;> intro <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    rename_i h;
    apply_fun ( fun x => x * v 3 ) at h ; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    simp_all +decide [ Fin.sum_univ_four ];
    rw [ ← h, ← mul_assoc, v_sq ] ; norm_num;
  contradiction

/-
Lemma stating that v0*v1 is not equal to v2*v3.
-/
lemma v0_v1_ne_v2_v3 : v 0 * v 1 ≠ v 2 * v 3 := by
  intro h;
  exact absurd ( pattern_101_cl4_fails ) ( by rw [ pattern_101_expansion ] ; erw [ h ] ; norm_num )

/-
Defining `v5` as the basis vectors of `Cl5` and proving that `v5 i * v5 i = 1`.
-/
open CliffordAlgebra

abbrev v5 (i : Fin 5) : Cl5 := ι Q5 (Pi.single i 1)

lemma v5_sq (i : Fin 5) : v5 i * v5 i = 1 := by
  fin_cases i <;> simp +decide [ Fin.sum_univ_succ ]

/-
Expansion of Pattern 103 product in Cl(4,0).
-/
lemma pattern_103_expansion : (e_cl4 1 - e_cl4 14) * (e_cl4 4 + e_cl4 11) = 2 • (v 0 * v 2) + 2 • (v 1 * v 3) := by
  -- Expand the product using the definition of `e_cl4`.
  simp [e_cl4_1, e_cl4_4, e_cl4_11, e_cl4_14];
  -- Apply the anticommutation relations to simplify the terms.
  have h_anticomm : v 0 * v 1 = -v 1 * v 0 ∧ v 0 * v 2 = -v 2 * v 0 ∧ v 0 * v 3 = -v 3 * v 0 ∧ v 1 * v 2 = -v 2 * v 1 ∧ v 1 * v 3 = -v 3 * v 1 ∧ v 2 * v 3 = -v 3 * v 2 := by
    have h_anticomm : ∀ i j : Fin 4, i ≠ j → v i * v j = - (v j * v i) := by
      exact?;
    exact ⟨ by simpa using h_anticomm 0 1 ( by decide ), by simpa using h_anticomm 0 2 ( by decide ), by simpa using h_anticomm 0 3 ( by decide ), by simpa using h_anticomm 1 2 ( by decide ), by simpa using h_anticomm 1 3 ( by decide ), by simpa using h_anticomm 2 3 ( by decide ) ⟩;
  simp_all +decide [ mul_assoc, sub_mul, mul_add ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_succ, mul_assoc ];
  grind

/-
Verification that Pattern 103 fails (is non-zero) in Cl(4,0).
-/
theorem pattern_103_cl4_fails : (e_cl4 1 - e_cl4 14) * (e_cl4 4 + e_cl4 11) ≠ 0 := by
  by_contra h;
  -- This implies that $v_0 * v_2 = -v_1 * v_3$.
  have h_eq : v 0 * v 2 = -v 1 * v 3 := by
    have h_eq : 2 • (v 0 * v 2) + 2 • (v 1 * v 3) = 0 := by
      exact h ▸ pattern_103_expansion ▸ rfl;
    have h_eq : 2 • (v 0 * v 2 + v 1 * v 3) = 0 := by
      rwa [ smul_add ];
    have h_eq : v 0 * v 2 + v 1 * v 3 = 0 := by
      exact smul_eq_zero.mp h_eq |> Or.resolve_left <| by norm_num;
    simpa using eq_neg_of_add_eq_zero_left h_eq;
  have := v_anticomm 0 2 ( by decide ) ; have := v_anticomm 1 3 ( by decide ) ; simp_all +decide [ mul_assoc ] ;
  -- This contradicts `v0_v1_ne_v2_v3`, so our assumption must be false.
  apply v0_v1_ne_v2_v3;
  rw [ show v 0 * v 1 = ( v 0 * v 2 ) * ( v 2 * v 1 ) by
        simp +decide [ mul_assoc, v_sq ];
        simp +decide [ ← mul_assoc, v_sq ];
        simp +decide [ Fin.sum_univ_four ], show v 2 * v 3 = ( v 2 * v 0 ) * ( v 0 * v 3 ) by
                                                                  simp +decide [ mul_assoc, v_sq ];
                                                                  simp +decide [ ← mul_assoc, v_sq ];
                                                                  simp +decide [ Fin.sum_univ_four ] ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_succ, mul_assoc ];
  rw [ show v 1 * ( v 2 * v 1 ) = -v 2 by
        rw [ ← mul_assoc, v_anticomm ] <;> norm_num;
        · rw [ mul_assoc, v_sq ] ; norm_num;
        · decide ] ; simp +decide [ mul_assoc, mul_left_comm ];
  have := v_anticomm 3 2 ( by decide ) ; simp_all +decide [ mul_assoc ] ;

/-
Expansion of Pattern 121 product in Cl(4,0).
-/
lemma pattern_121_expansion : (e_cl4 2 - e_cl4 13) * (e_cl4 1 - e_cl4 14) = -2 • (v 0 * v 1) - 2 • (v 2 * v 3) := by
  rw [ e_cl4_14, e_cl4_2, e_cl4_13, e_cl4_1 ];
  simp_all +decide [ two_mul, mul_assoc, sub_mul, mul_sub ];
  -- Apply the anticommutation relations to simplify the expression.
  have h_anticomm : v 1 * v 0 = -v 0 * v 1 ∧ v 2 * v 0 = -v 0 * v 2 ∧ v 3 * v 0 = -v 0 * v 3 ∧ v 1 * v 2 = -v 2 * v 1 ∧ v 1 * v 3 = -v 3 * v 1 ∧ v 2 * v 3 = -v 3 * v 2 := by
    apply And.intro;
    · convert v_anticomm 1 0 ( by decide ) using 1;
      rw [ neg_mul ];
    · have h_anticomm : ∀ i j : Fin 4, i ≠ j → v i * v j = -v j * v i := by
        norm_num +zetaDelta at *;
        exact?;
      exact ⟨ h_anticomm _ _ <| by decide, h_anticomm _ _ <| by decide, h_anticomm _ _ <| by decide, h_anticomm _ _ <| by decide, h_anticomm _ _ <| by decide ⟩;
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_four, mul_assoc ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_four, Pi.single_apply ];
  grind

/-
Proving the anticommutation relation for basis vectors in Cl(5,0): v_i * v_j = - v_j * v_i for i != j.
-/
lemma v5_anticomm (i j : Fin 5) (h : i ≠ j) : v5 i * v5 j = - (v5 j * v5 i) := by
  -- By definition of Clifford algebra, we know that $v_i v_j + v_j v_i = 0$ for $i \neq j$.
  have h_anticomm : ∀ i j : Fin 5, i ≠ j → v5 i * v5 j + v5 j * v5 i = 0 := by
    intros i j hij
    have h_anticomm : v5 i * v5 j + v5 j * v5 i = ι Q5 (Pi.single i 1 + Pi.single j 1) * ι Q5 (Pi.single i 1 + Pi.single j 1) - ι Q5 (Pi.single i 1) * ι Q5 (Pi.single i 1) - ι Q5 (Pi.single j 1) * ι Q5 (Pi.single j 1) := by
      simp +decide [ add_mul, mul_add, sub_mul, mul_sub ];
      grind +ring;
    rw [ h_anticomm, ← sq, ← sq, ← sq ];
    rw [ sq, sq, sq, CliffordAlgebra.ι_sq_scalar, CliffordAlgebra.ι_sq_scalar, CliffordAlgebra.ι_sq_scalar ];
    simp +decide [ Fin.sum_univ_succ, Pi.single_apply ];
    fin_cases i <;> fin_cases j <;> simp +decide at hij ⊢;
  exact eq_neg_of_add_eq_zero_left <| h_anticomm i j h

/-
Verification that Pattern 19 fails in Cl(4,0) using previously proved lemmas.
-/
theorem pattern_19_cl4_fails : (e_cl4 1 + e_cl4 14) * (e_cl4 4 - e_cl4 11) ≠ 0 := by
  rw [pattern_19_expansion]
  intro h
  have h_eq : 2 • (v 0 * v 2) = 2 • (v 1 * v 3) := by
    rw [sub_eq_zero] at h
    exact h
  have h_eq' : v 0 * v 2 = v 1 * v 3 := smul_right_injective _ two_ne_zero h_eq
  apply v1_v3_ne_v0_v2
  rw [h_eq']

/-
Verification of Pattern 59 in Cl(5,0).
-/
theorem pattern_59_cl5 : (e_cl5 3 + e_cl5 12) * (e_cl5 5 + e_cl5 10) = 0 := by
  have h_expand : (e_cl5 3 + e_cl5 12) * (e_cl5 5 + e_cl5 10) = 0 := by
    have h1 : e_cl5 3 = v5 0 * v5 1 := by
      unfold e_cl5;
      simp +decide [ List.finRange, List.foldl ]
    have h2 : e_cl5 12 = v5 2 * v5 3 := by
      unfold e_cl5;
      simp +decide [ List.finRange, List.filter_cons, List.filter_nil ]
    have h3 : e_cl5 5 = v5 0 * v5 2 := by
      unfold e_cl5; simp +decide ;
      simp +decide [ List.finRange, List.filter_cons, List.filter_nil ]
    have h4 : e_cl5 10 = v5 1 * v5 3 := by
      unfold e_cl5;
      simp +decide [ List.finRange, List.filter_cons ]
    simp_all +decide [ mul_add, add_mul, mul_assoc ];
    -- Apply the anticommutation relation to each term.
    have h_anticomm : v5 0 * v5 1 = -v5 1 * v5 0 ∧ v5 0 * v5 2 = -v5 2 * v5 0 ∧ v5 0 * v5 3 = -v5 3 * v5 0 ∧ v5 1 * v5 2 = -v5 2 * v5 1 ∧ v5 1 * v5 3 = -v5 3 * v5 1 ∧ v5 2 * v5 3 = -v5 3 * v5 2 := by
      exact ⟨ by rw [ v5_anticomm 0 1 ( by decide ), neg_mul ], by rw [ v5_anticomm 0 2 ( by decide ), neg_mul ], by rw [ v5_anticomm 0 3 ( by decide ), neg_mul ], by rw [ v5_anticomm 1 2 ( by decide ), neg_mul ], by rw [ v5_anticomm 1 3 ( by decide ), neg_mul ], by rw [ v5_anticomm 2 3 ( by decide ), neg_mul ] ⟩;
    simp_all +decide [ ← mul_assoc ];
    simp_all +decide [ Fin.sum_univ_succ, mul_assoc ];
    simp_all +decide [ ← mul_assoc ];
    simp +decide [ Fin.sum_univ_succ, Pi.single_apply ];
    abel1;
  exact h_expand

/-
Helper lemmas expanding `e_cl5` for specific indices into products of basis vectors `v5`.
-/
lemma e_cl5_1 : e_cl5 1 = v5 0 := by
  -- By definition of `e_cl5`, we know that `e_cl5 1` is the product of the basis vectors where the binary representation of 1 has a 1 in the 0th position.
  simp [e_cl5];
  -- The list of indices where the binary representation of 1 has a 1 is [0].
  have h_indices : List.filter (fun (i : Fin 5) => Nat.testBit 1 (↑i : ℕ)) (List.finRange 5) = [0] := by
    native_decide;
  aesop

lemma e_cl5_4 : e_cl5 4 = v5 2 := by
  -- By definition of `e_cl5`, we have `e_cl5 4 = v5 2` because the third bit of 4 is 1.
  simp [e_cl5, v5];
  simp +decide [ List.finRange, List.filter_cons, List.filter_nil ]

lemma e_cl5_11 : e_cl5 11 = v5 0 * v5 1 * v5 3 := by
  -- By definition of `e_cl5`, we can expand it using the indices we selected.
  simp [e_cl5, List.foldl];
  simp +decide [ List.finRange, List.filter_cons ]

lemma e_cl5_14 : e_cl5 14 = v5 1 * v5 2 * v5 3 := by
  unfold e_cl5;
  simp +decide [ List.finRange, List.filter_cons, List.filter_nil ]

/-
Verification of Pattern 84 in Cl(5,0).
-/
theorem pattern_84_cl5 : (e_cl5 4 + e_cl5 11) * (e_cl5 6 + e_cl5 9) = 0 := by
  rw [ show e_cl5 6 = v5 1 * v5 2 by
        unfold e_cl5;
        simp +decide [ List.finRange ], show e_cl5 9 = v5 0 * v5 3 by
                                              unfold e_cl5; simp +decide [ v5 ];
                                              simp +decide [ List.finRange, List.filter_cons, List.filter_nil ] ];
  simp +decide [ add_mul, mul_add, e_cl5_4, e_cl5_11 ];
  have := v5_anticomm 0 1 ( by decide ) ; have := v5_anticomm 0 2 ( by decide ) ; have := v5_anticomm 0 3 ( by decide ) ; have := v5_anticomm 1 2 ( by decide ) ; have := v5_anticomm 1 3 ( by decide ) ; have := v5_anticomm 2 3 ( by decide ) ; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
  simp_all +decide [ ← mul_assoc ];
  simp_all +decide [ Fin.sum_univ_succ, mul_assoc, mul_comm, mul_left_comm ];
  simp_all +decide [ ← mul_assoc, v5_sq ];
  simp_all +decide [ Fin.sum_univ_succ, Pi.single_apply ];
  abel1